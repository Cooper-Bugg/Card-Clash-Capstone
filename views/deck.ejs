<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title><%= pageTitle %> | Card Clash</title>
    <link rel="stylesheet" href="/styles.css" />
  </head>
  <body class="page">
    <div class="background-glow"></div>
    <header class="top-bar">
      <div class="brand">
        <div class="brand-title">Card Clash</div>
        <div class="brand-subtitle">Deck Builder</div>
      </div>
      <nav class="top-nav">
        <a class="nav-link" href="/dashboard">Dashboard</a>
        <a class="nav-link is-active" href="/deck/new">Create Deck</a>
        <a class="nav-link" href="/sessions">Sessions</a>
        <form method="post" action="/logout" style="margin: 0;">
          <button class="nav-link nav-link--danger" type="submit">Log Out</button>
        </form>
      </nav>
    </header>

    <main class="page-shell">
      <section class="panel hero-panel">
        <div>
          <h1>
            <% if (mode === "edit") { %>
              Edit Deck
            <% } else { %>
              Create a New Deck
            <% } %>
          </h1>
          <p>Select a question from the sidebar to edit its properties.</p>
        </div>
        <a class="btn btn-primary btn-compact" href="/dashboard">Return to Dashboard</a>
      </section>

      <section class="deck-editor-panel">
        <form id="deckForm" class="form" method="post" action="/deck">
          <input type="hidden" name="id" value="<%= deck.id || "" %>" />

          <div class="panel-header">
            <label class="form-field" style="width: 100%; max-width: 400px; margin: 0;">
              <span>Deck Title</span>
              <input type="text" name="title" value="<%= deck.title %>" required />
            </label>
            <div class="form-actions" style="margin-top: 0;">
              <button class="btn btn-primary" type="submit">Save Deck</button>
            </div>
          </div>

          <textarea
            id="contentJson"
            name="contentJson"
            class="visually-hidden"
          ><%= deck.contentJson %></textarea>

          <div class="deck-editor-layout">
            <aside class="editor-sidebar">
              <div class="sidebar-header">
                <h3>Questions</h3>
                <button type="button" id="addQuestionBtn" class="btn btn-primary btn-compact">Add</button>
              </div>
              <div id="questionList" class="question-nav-list"></div>
            </aside>

            <section id="questionDetail" class="editor-detail"></section>
          </div>
        </form>
      </section>
    </main>

    <script>
      const jsonField = document.getElementById("contentJson");
      const questionListContainer = document.getElementById("questionList");
      const questionDetailContainer = document.getElementById("questionDetail");
      const addQuestionBtn = document.getElementById("addQuestionBtn");

      let deckData = { questions: [] };
      let activeIndex = 0;

      /*
      Initializes the application state from the hidden JSON payload provided by the server.
      Sets a default empty question if the parsed array is empty to prevent a blank interface.
      */
      function loadInitialData() {
        try {
          const parsed = JSON.parse(jsonField.value);
          if (parsed && Array.isArray(parsed.questions)) {
            deckData.questions = parsed.questions;
          }
        } catch (error) {
          console.warn("Failed to parse initial deck JSON. Defaulting to empty array.");
        }

        if (deckData.questions.length === 0) {
          appendEmptyQuestion();
        }
      }

      /*
      Serializes the current state back to the hidden textarea.
      This ensures the server receives the most up-to-date data upon form submission.
      */
      function syncDataToField() {
        jsonField.value = JSON.stringify(deckData, null, 2);
      }

      /*
      Pushes a structured empty question object to the state array.
      */
      function appendEmptyQuestion() {
        deckData.questions.push({
          questionText: "",
          optionA: "",
          optionB: "",
          optionC: "",
          optionD: "",
          correctAnswer: "A"
        });
      }

      /*
      Handles the logic for modifying data properties of the currently active question.
      Triggers a data sync immediately after mutation.
      */
      function updateActiveQuestionProperty(key, value) {
        if (deckData.questions[activeIndex]) {
          deckData.questions[activeIndex][key] = value;
          syncDataToField();
        }
      }

      /*
      Deletes a question from the array based on its index.
      Adjusts the active index to prevent out-of-bounds rendering errors.
      */
      function removeQuestion(indexToRemove) {
        deckData.questions.splice(indexToRemove, 1);

        if (deckData.questions.length === 0) {
          appendEmptyQuestion();
          activeIndex = 0;
        } else if (activeIndex >= deckData.questions.length) {
          activeIndex = deckData.questions.length - 1;
        } else if (activeIndex === indexToRemove) {
          activeIndex = Math.max(0, indexToRemove - 1);
        }

        syncDataToField();
        renderInterface();
      }

      /*
      Generates the navigation buttons within the left sidebar.
      Attaches click listeners to update the active index and refresh the detail view.
      */
      function renderSidebar() {
        questionListContainer.innerHTML = "";

        for (let i = 0; i < deckData.questions.length; i += 1) {
          const navItem = document.createElement("button");
          navItem.type = "button";
          navItem.className = "question-nav-item";
          if (i === activeIndex) {
            navItem.classList.add("is-active");
          }
          navItem.textContent = `Question ${i + 1}`;
          navItem.addEventListener("click", () => {
            activeIndex = i;
            renderInterface();
          });
          questionListContainer.appendChild(navItem);
        }
      }

      /*
      Generates the input form for the currently selected question in the right pane.
      Binds input events directly to the state management functions.
      */
      function renderDetailPane() {
        questionDetailContainer.innerHTML = "";

        const currentQuestion = deckData.questions[activeIndex];
        if (!currentQuestion) {
          questionDetailContainer.innerHTML = `<div class="editor-empty-state">No question selected.</div>`;
          return;
        }

        const headerDiv = document.createElement("div");
        headerDiv.className = "question-header";

        const title = document.createElement("h2");
        title.textContent = `Editing Question ${activeIndex + 1}`;

        const removeBtn = document.createElement("button");
        removeBtn.type = "button";
        removeBtn.className = "btn btn-primary btn-compact";
        removeBtn.textContent = "Delete Question";
        removeBtn.addEventListener("click", () => removeQuestion(activeIndex));

        headerDiv.appendChild(title);
        headerDiv.appendChild(removeBtn);

        const promptLabel = document.createElement("label");
        promptLabel.className = "form-field";
        const promptSpan = document.createElement("span");
        promptSpan.textContent = "Question Prompt";
        const promptInput = document.createElement("input");
        promptInput.type = "text";
        promptInput.value = currentQuestion.questionText;
        promptInput.addEventListener("input", (e) => updateActiveQuestionProperty("questionText", e.target.value));
        promptLabel.appendChild(promptSpan);
        promptLabel.appendChild(promptInput);

        questionDetailContainer.appendChild(headerDiv);
        questionDetailContainer.appendChild(promptLabel);

        const options = ["A", "B", "C", "D"];
        const optionKeys = ["optionA", "optionB", "optionC", "optionD"];

        const answerSection = document.createElement("div");
        answerSection.className = "answer-section";

        const answerHeader = document.createElement("div");
        answerHeader.className = "answer-header";
        answerHeader.textContent = "Answer Options";
        answerSection.appendChild(answerHeader);

        const answerList = document.createElement("div");
        answerList.className = "answer-list";

        for (let j = 0; j < options.length; j += 1) {
          const rowDiv = document.createElement("div");
          rowDiv.className = "answer-row";

          const radioInput = document.createElement("input");
          radioInput.type = "radio";
          radioInput.name = "correctAnswerSelect";
          radioInput.value = options[j];
          radioInput.checked = currentQuestion.correctAnswer === options[j];
          radioInput.addEventListener("change", (e) => updateActiveQuestionProperty("correctAnswer", e.target.value));

          const letterSpan = document.createElement("span");
          letterSpan.className = "answer-label";
          letterSpan.textContent = options[j];

          const textInput = document.createElement("input");
          textInput.type = "text";
          textInput.value = currentQuestion[optionKeys[j]];
          textInput.addEventListener("input", (e) => updateActiveQuestionProperty(optionKeys[j], e.target.value));

          rowDiv.appendChild(radioInput);
          rowDiv.appendChild(letterSpan);
          rowDiv.appendChild(textInput);
          answerList.appendChild(rowDiv);
        }

        answerSection.appendChild(answerList);
        questionDetailContainer.appendChild(answerSection);
      }

      /*
      Coordinates the complete UI refresh sequence.
      */
      function renderInterface() {
        renderSidebar();
        renderDetailPane();
      }

      addQuestionBtn.addEventListener("click", () => {
        appendEmptyQuestion();
        activeIndex = deckData.questions.length - 1;
        syncDataToField();
        renderInterface();
      });

      loadInitialData();
      renderInterface();
      syncDataToField();
    </script>
  </body>
</html>